package com.dubture.twig.core.parser.ast;

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////    $Id: php_compiler_ast_parser.cup,v 1.32 2011/07/19 07:54:30 zzhongwei Exp $
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


import java.util.*;
import org.eclipse.dltk.ast.*;
import org.eclipse.dltk.ast.declarations.*;
import org.eclipse.dltk.ast.expressions.*;
import org.eclipse.dltk.ast.references.*;
import org.eclipse.dltk.ast.statements.*;


parser code {:

	class ModifierDocPair {
		public int modifier;
		public PHPDocBlock doc;
		
		public ModifierDocPair(int modifier, PHPDocBlock doc) {
			this.modifier = modifier;
			this.doc = doc;
		}
	}
	
	public Expression createDispatch(Expression dispatcher, Expression property) {

		if (property.getKind() == ASTNodeKinds.REFLECTION_CALL_EXPRESSION) {
			((ReflectionCallExpression) property).setReceiver (dispatcher);
			dispatcher = property;
		} else if (property.getKind() == ASTNodeKinds.METHOD_INVOCATION) {
			PHPCallExpression callExpression = (PHPCallExpression) property;
			dispatcher = new PHPCallExpression(dispatcher.sourceStart(), callExpression.sourceEnd(), dispatcher, callExpression.getCallName(), callExpression.getArgs());
		} else {
			dispatcher =  new FieldAccess(dispatcher.sourceStart(), property.sourceEnd(), dispatcher, property);
		}

		return dispatcher;
	}

	protected String getTokenName(int token) {
		return PhpTokenNames.getName(token);
	}
:}

/* terminals */

terminal  String T_LNUMBER;
terminal  String T_DNUMBER;
terminal  String T_STRING;
terminal  String T_STRING_VARNAME;
terminal  String T_VARIABLE;
terminal  String T_NUM_STRING;
terminal  T_INLINE_HTML;
terminal  String T_ENCAPSED_AND_WHITESPACE;
terminal  String T_CONSTANT_ENCAPSED_STRING;
terminal  T_DOLLAR_OPEN_CURLY_BRACES;
terminal  T_CURLY_OPEN_WITH_DOLAR;
terminal  T_CURLY_OPEN;
terminal  T_CURLY_CLOSE;
terminal  T_PAAMAYIM_NEKUDOTAYIM;

terminal T_COMMA;
terminal String T_LOGICAL_OR,T_LOGICAL_XOR,T_LOGICAL_AND,T_PRINT;
terminal T_EQUAL;
terminal T_PLUS_EQUAL,T_MINUS_EQUAL,T_MUL_EQUAL,T_DIV_EQUAL,T_CONCAT_EQUAL,T_MOD_EQUAL,T_AND_EQUAL,T_OR_EQUAL,T_XOR_EQUAL,T_SL_EQUAL,T_SR_EQUAL;
terminal T_QUESTION_MARK;
terminal T_SEMICOLON;
terminal T_BOOLEAN_OR, T_BOOLEAN_AND;
terminal T_OR;
terminal T_KOVA;
terminal T_REFERENCE;
terminal T_IS_EQUAL,T_IS_NOT_EQUAL,T_IS_IDENTICAL,T_IS_NOT_IDENTICAL;
terminal T_IS_SMALLER_OR_EQUAL,T_IS_GREATER_OR_EQUAL;
terminal T_RGREATER;
terminal T_LGREATER;
terminal T_SL,T_SR;
terminal T_PLUS;
terminal T_MINUS;
terminal T_TIMES;
terminal T_DIV;
terminal T_PRECENT;
terminal T_NOT;
terminal T_TILDA;
terminal T_NEKUDA;


/* Non terminals */


/* added the following rules for improving error recovery*/
non terminal Statement class_closure;
non terminal PHPMethodDeclaration function_body;
non terminal errorOrNot;

precedence left T_COMMA;
precedence left T_LOGICAL_OR;
precedence left T_LOGICAL_XOR;
precedence left T_LOGICAL_AND;
precedence right T_PRINT;
precedence left T_EQUAL, T_PLUS_EQUAL,T_MINUS_EQUAL,T_MUL_EQUAL,T_DIV_EQUAL,T_CONCAT_EQUAL,T_MOD_EQUAL,T_AND_EQUAL,T_OR_EQUAL,T_XOR_EQUAL,T_SL_EQUAL,T_SR_EQUAL;
precedence left T_QUESTION_MARK,T_SEMICOLON;
precedence left T_BOOLEAN_OR;
precedence left T_BOOLEAN_AND;
precedence left T_OR;
precedence left T_KOVA;
precedence left T_REFERENCE;

precedence nonassoc T_IS_EQUAL,T_IS_NOT_EQUAL,T_IS_IDENTICAL,T_IS_NOT_IDENTICAL;
precedence nonassoc T_RGREATER,T_IS_SMALLER_OR_EQUAL,T_LGREATER,T_IS_GREATER_OR_EQUAL;
precedence left T_SL,T_SR;
precedence left T_PLUS,T_MINUS,T_NEKUDA;
precedence left T_TIMES,T_DIV,T_PRECENT;
precedence right T_NOT;
precedence right T_TILDA,T_INC,T_DEC,T_INT_CAST,T_DOUBLE_CAST,T_STRING_CAST,T_ARRAY_CAST,T_OBJECT_CAST,T_BOOL_CAST,T_UNSET_CAST,T_AT;
precedence right T_OPEN_RECT;
precedence left T_ELSEIF;
precedence left T_ELSE;
precedence left T_ENDIF;
precedence right T_STATIC, T_ABSTRACT, T_FINAL, T_PRIVATE, T_PROTECTED, T_PUBLIC;

thestart ::=
top_statement_list:statementList
{:
	PHPModuleDeclaration program = parser.getModuleDeclaration();

	PhpAstLexer phpAstLexer = (PhpAstLexer) parser.getScanner();
	List commentList = phpAstLexer.getCommentList();
	Iterator i = commentList.iterator();
	while (i.hasNext()) {
		Object c = i.next();
		if (c instanceof VarComment) {
			program.getVarComments().add((VarComment)c);
		} else if (c instanceof PHPDocBlock) {
			program.getPhpDocBlocks().add((PHPDocBlock) c);
		}
	}
	
	program.setStart(statementListleft);
	program.setEnd(statementListright + 1);
	RESULT = program; 
:}
;

namespace_name ::=
namespace_name_list:list
{:
	StringBuilder namespaceNameBuf = new StringBuilder();
	FullyQualifiedReference fullyQualifiedName = null;
	Iterator i = list.iterator();
	while (i.hasNext()) {
		String s = (String) i.next();
		if (i.hasNext()) {
			if (namespaceNameBuf.length() != 0) {
				namespaceNameBuf.append('\\');
			}
			namespaceNameBuf.append(s);
		} else {
			NamespaceReference namespaceRef = (namespaceNameBuf.length() != 0) ? 
				new NamespaceReference(listleft, listright - s.length() - 1, namespaceNameBuf.toString()) : null;
			fullyQualifiedName = new FullyQualifiedReference(listleft, listright, s, namespaceRef);
		}
	}
	RESULT = fullyQualifiedName;
:}
;

top_statement_list ::=
top_statement_list:statementList top_statement:statement
{:
	if(statement != null) {
		parser.addStatement(statement);
		if(parser.pendingStatement != null){
			parser.addStatement(parser.pendingStatement);
			parser.pendingStatement = null;
		}
	}
	while(!parser.declarations.isEmpty()) {
		parser.addStatement(parser.declarations.pop());
	}
:}

| /* empty */
;

namespace_statement_list ::=
namespace_statement_list:statementList top_statement:statement
{:
	// Ignore null statements
	if(statement != null) {
		statementList.add(statement);
		if(statement.getKind() == ASTNodeKinds.AST_ERROR){
			if(!parser.declarations.isEmpty()) {
				Statement node = parser.declarations.peek();
				if(node.sourceStart() == statement.sourceStart() && node.sourceEnd() == statement.sourceEnd()) {
					statementList.add(parser.declarations.pop());
				}
			}		
		}
	}
	if(!(parser.declarations.peek() instanceof NamespaceDeclaration)) {
		statementList.add(parser.declarations.pop());
	}
	RESULT = statementList;	
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

top_statement ::=
statement:statement
{: 
	RESULT = statement;
:}

| function_declaration_statement:statement
{: 
	RESULT = statement; 
:}

| class_declaration_statement:statement
{: 
	RESULT = statement; 
:}

named_namespace_body:body
{:
	RESULT = body;
:}

namespace_body:body
{:
	RESULT = body;
:}

| constant_declaration:decList T_SEMICOLON
{:
	Iterator i = decList.iterator();
	while (i.hasNext()) {
		ASTNode[] decl = (ASTNode[]) i.next();
		ConstantReference constant = (ConstantReference)decl[0];
		Expression initializer = (Expression)decl[1];
		
		PHPDocBlock docBlock = null;
		if (decl.length == 3) {
			docBlock = (PHPDocBlock)decl[2];
		}
		int start = constant.sourceStart();
		int end = (initializer == null ? constant.sourceEnd() : initializer.sourceEnd());
		parser.declarations.push(new ConstantDeclaration(constant, initializer, decListleft, end, docBlock));
	}
:}
;

named_namespace_body ::=
T_SEMICOLON:end /* unbracketed syntax */
{:
	NamespaceDeclaration namespaceDeclaration = (NamespaceDeclaration)parser.declarations.pop();
	namespaceDeclaration.setEnd(endright);
	namespaceDeclaration.setBracketed(false);

	parser.currentNamespace = namespaceDeclaration;

	parser.metUnbracketedNSDecl = true;
	if (parser.metBracketedNSDecl) {
		parser.reportError(new ASTError(namespaceDeclaration.sourceStart(), endright), "Cannot mix bracketed namespace declarations with unbracketed namespace declarations");
	}
	
	RESULT = namespaceDeclaration;
:}
| namespace_body:body
{:
	RESULT = body;
:}
;

namespace_body ::=
T_CURLY_OPEN:start namespace_statement_list:statementList T_CURLY_CLOSE:end
{:
	NamespaceDeclaration namespaceDeclaration = (NamespaceDeclaration)parser.declarations.pop();
	namespaceDeclaration.getBody().setStart(startleft);
	namespaceDeclaration.getBody().setEnd(endright);
	namespaceDeclaration.getBody().getStatements().clear();
	namespaceDeclaration.getBody().acceptStatements(statementList);
	namespaceDeclaration.setEnd(endright);
	
	parser.metBracketedNSDecl = true;
	if (parser.metUnbracketedNSDecl) {
		parser.reportError(new ASTError(namespaceDeclaration.sourceStart(), endright), "Cannot mix bracketed namespace declarations with unbracketed namespace declarations");
	}
	
	RESULT = namespaceDeclaration;
:}
| error:theError
{:
	RESULT = (NamespaceDeclaration)parser.declarations.pop();
:}
;


use_declarations ::=
use_declarations:useDeclList T_COMMA use_declaration:useDecl
{:
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}

| use_declaration:useDecl
{:
	List useDeclList = new LinkedList();
	useDeclList.add(useDecl);
	RESULT = useDeclList;
:}
;

use_declaration ::=
namespace_name:name
{:
	UsePart usePart = new UsePart(name, null);
	RESULT = usePart;
:}
;

inner_statement_list ::=
inner_statement_list:statementList inner_statement:statement
{:
	// Ignore null statements
	if(statement != null) {
		statementList.add(statement);
		if(statement.getKind() == ASTNodeKinds.AST_ERROR){
			if(!parser.declarations.isEmpty()) {
				Statement node = parser.declarations.peek();
				if(node.sourceStart() == statement.sourceStart() && node.sourceEnd() == statement.sourceEnd()) {
					statementList.add(parser.declarations.pop());
				}
			}		
		}
	}
	RESULT = statementList;
:}

| /* empty */
{: 
	RESULT = new LinkedList(); 
:}
;

inner_statement ::=
statement:statement
{: 
	RESULT = statement; 
:}

| function_declaration_statement:statement
{: 
	RESULT = statement; 
:}

| class_declaration_statement:statement
{: 
	RESULT = statement; 
:}
;

statement ::=
unticked_statement:statement
{: 
	RESULT = statement; 
:}
| T_STRING:label T_NEKUDOTAIM:end
{:
	RESULT = new GotoLabel(labelleft, endright, label);
:}
| error:theError /* error statement */
{:
	parser.reportError();
	ASTError error = new ASTError(theErrorleft, theErrorright);
	RESULT = error;	
:}
| T_VAR_COMMENT
;

unticked_statement ::=
T_CURLY_OPEN:token
{:
	Block block = new Block(tokenleft, tokenleft, new LinkedList());
	parser.declarations.push(block);
	
:}
inner_statement_list:statementList T_CURLY_CLOSE:end
{:
	Block block = (Block)parser.declarations.pop();
	block.setEnd(endright);
	block.getStatements().clear();
	block.acceptStatements(statementList);
	
	RESULT = block;
:}

| T_INLINE_HTML

| expr:expr T_SEMICOLON:end
{: 
	ExpressionStatement expressionStatement = new ExpressionStatement(exprleft, endright, expr);
	RESULT = expressionStatement;
:}

| T_SEMICOLON:token /* empty statement */
{: 
	RESULT = new EmptyStatement(tokenleft, tokenright); 
:}
;

additional_catches ::=
non_empty_additional_catches:list
{:
	RESULT = list;
:}

| /* empty */
{:
	List list = new LinkedList();
	RESULT = list;	
:}
;

non_empty_additional_catches ::=
additional_catch:catch_statement
{:
	List list = new LinkedList();
	list.add(catch_statement);
	RESULT = list;	
:}
| non_empty_additional_catches:list additional_catch:catch_statement
{:
	list.add(catch_statement);
	RESULT = list;	
:}
;

unset_variables ::=
unset_variable:var
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	list.addNode(var);
	RESULT = list;
:}

| unset_variables:list T_COMMA unset_variable:var
{:
	list.addNode(var);
	RESULT = list;
:}
;

unset_variable ::=
variable:var
{:
	RESULT = var;
:}
;

use_filename ::=
T_CONSTANT_ENCAPSED_STRING:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}

| T_OPEN_PARENTHESE:start T_CONSTANT_ENCAPSED_STRING:scalar T_CLOSE_PARENTHESE:end
{:
	Scalar s = new Scalar(startleft, endright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}
;

function_declaration_statement ::=
unticked_function_declaration_statement:functionDeclaration
{:
	RESULT = functionDeclaration;
:}
;

class_declaration_statement ::=
unticked_class_declaration_statement:classDeclaration
{:
	RESULT = classDeclaration;
:}
;

is_reference ::=
/* empty */
{:
	RESULT = Boolean.FALSE;
:}
| T_REFERENCE
{:
	RESULT = Boolean.TRUE;
:}
;

function_body ::=
T_CURLY_OPEN:blockStart inner_statement_list:statementList T_CURLY_CLOSE:blockEnd
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration)parser.declarations.pop();
	Block block = functionDeclaration.getBody();
	block.setStart(blockStartleft);
	block.setEnd(blockEndright);
	block.getStatements().clear();
	block.acceptStatements(statementList);
	functionDeclaration.setEnd(blockEndright);
	RESULT = functionDeclaration;
:}
| error:theError
{:
	RESULT = (PHPMethodDeclaration)parser.declarations.pop();
:}
;

unticked_class_declaration_statement ::=
class_entry_type:modifier T_STRING:className
{:
	ClassDeclaration classDeclaration = new ClassDeclaration(modifierleft ,classNameright, classNameleft, classNameright, modifier.modifier, className, null, null, new Block(classNameright,classNameright,null), modifier.doc);
	classDeclaration.setRecovered(true);
	parser.addDeclarationStatement(classDeclaration);
	parser.declarations.push(classDeclaration);
:}
extends_from:superClass errorOrNot implements_list:interfaces
{:
	ClassDeclaration classDeclaration = (ClassDeclaration)parser.declarations.peek();
	if (superClass != null) {
		classDeclaration.setSuperClass(superClass);
	}
	if (interfaces != null) {
		classDeclaration.setInterfaceList(interfaces);
	}
	classDeclaration.setEnd(interfacesright);
	classDeclaration.getBody().setStart(interfacesright);
	classDeclaration.getBody().setEnd(interfacesright);
:}
T_CURLY_OPEN:blockStart class_statement_list:statementList class_closure:blockEnd
{:
	if(blockEnd != null) {
		parser.reportError(new ASTError(statementListright - 1, statementListright), "syntax error, unfinished class declaration");
		parser.pendingStatement = blockEnd;
	}
	ClassDeclaration classDeclaration = (ClassDeclaration)parser.declarations.pop();
	classDeclaration.setRecovered(false);
	classDeclaration.setEnd(blockEndright);
	classDeclaration.getBody().setStart(blockStartleft);
	classDeclaration.getBody().setEnd(blockEndright);
	RESULT = classDeclaration;
:}

|
interface_entry:start T_STRING:className
interface_extends_list:interfaces
{:
	InterfaceDeclaration interfaceDeclaration = new InterfaceDeclaration(startleft ,interfacesright, classNameleft, classNameright, className, interfaces, new Block(interfacesright,interfacesright,null), start);
	interfaceDeclaration.setRecovered(true);
	parser.declarations.push(interfaceDeclaration);
:}
T_CURLY_OPEN:blockStart class_statement_list:statementList class_closure:blockEnd
{:
	if(blockEnd != null) {
		parser.reportError(new ASTError(statementListright - 1, statementListright), "syntax error, unfinished class declaration");
		parser.pendingStatement = blockEnd;
	}

	InterfaceDeclaration interfaceDeclaration = (InterfaceDeclaration)parser.declarations.pop();
	interfaceDeclaration.setRecovered(false);
	interfaceDeclaration.setEnd(blockEndright);
	interfaceDeclaration.getBody().setStart(blockStartleft);
	interfaceDeclaration.getBody().setEnd(blockEndright);
	RESULT = interfaceDeclaration;
:}
;

errorOrNot ::=
error
|
;

/* Here go all elements that trigger the class closure */
class_closure ::=
T_CURLY_CLOSE /* normal behaviour */

/* error recovery - function declaration closes current class */
/* XXX: This is disabled for now because of lambda functions
function_declaration_statement:statement 
{:
	RESULT = statement;
:}
*/

/* error recovery - another class declaration closes current class */
| class_declaration_statement:statement
{:
	RESULT = statement;
:}
;


parameter_list ::=
non_empty_parameter_list:list
{:
	RESULT = list;
:}

| /* empty */
{:
	List list = new LinkedList();
	RESULT = list;
:}
;

non_empty_parameter_list ::=
parameter:parameter
{:
	List list = new LinkedList();
	if(parameter != null) {
		list.add(parameter);
	}
	RESULT = list;
:}

| non_empty_parameter_list:list T_COMMA parameter:parameter
{:
	if(parameter != null) {
		list.add(parameter);
	}
	RESULT = list;
:}
| non_empty_parameter_list:list T_COMMA:comma /* error recovery */
{:
	parser.reportError(new ASTError(commaleft, commaright), "syntax error, unexpected ','");
	RESULT = list;
:}
;

parameter ::=
optional_class_type:classType T_VARIABLE:var
{:
	int start = classType == null ? varleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameter(start, varright, classType, v);
	RESULT = parameter;	
:}

| optional_class_type:classType T_REFERENCE:ref T_VARIABLE:var
{:
	int start = classType == null ? refleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameterByReference(start, varright, classType, v);
	RESULT = parameter;	
:}

| optional_class_type:classType T_VARIABLE:var T_EQUAL static_scalar:scalar
{:
	int start = classType == null ? varleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameter(start, scalarright, classType, v, scalar);
	RESULT = parameter;	
:}

| optional_class_type:classType T_REFERENCE:ref T_VARIABLE:var T_EQUAL static_scalar:scalar
{:
	int start = classType == null ? refleft : classTypeleft;
	VariableReference v = new VariableReference(varleft, varright, var, PHPVariableKind.LOCAL);
	FormalParameter parameter = new FormalParameterByReference(start, scalarright, classType, v, scalar);
	RESULT = parameter;	
:}
| error:theError
{:
	parser.reportError(new ASTError(theErrorleft, theErrorright));
	RESULT = null;	
:}
;

optional_class_type ::=
/* empty */
{:
	RESULT = null;
:}

| fully_qualified_class_name:className
{:
	RESULT = className;
:}

| T_ARRAY:array
{:
	TypeReference reference = new TypeReference(arrayleft, arrayright, "array");
	RESULT = reference;
:}
;

function_call_parameter_list ::=
non_empty_function_call_parameter_list:paramsList
{:
	RESULT = paramsList;
:}

| /* empty */
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	RESULT = list;
:}
;

non_empty_function_call_parameter_list ::=
expr_without_variable:var
{:
	PHPCallArgumentsList paramsList = new PHPCallArgumentsList();
	paramsList.addNode(var);	
	RESULT = paramsList;
:}

| variable:var
{:
	PHPCallArgumentsList paramsList = new PHPCallArgumentsList();
	paramsList.addNode(var);	
	RESULT = paramsList;
:}

| T_REFERENCE:start w_variable:var
{:
	PHPCallArgumentsList paramsList = new PHPCallArgumentsList();
	Expression var_ref = new ReferenceExpression(startleft, varright, var);
	paramsList.addNode(var_ref);	
	RESULT = paramsList;
:}

| non_empty_function_call_parameter_list:paramsList T_COMMA expr_without_variable:var
{:
	paramsList.addNode(var);
	RESULT = paramsList;
:}

| non_empty_function_call_parameter_list:paramsList T_COMMA variable:var
{:
	paramsList.addNode(var);	
	RESULT = paramsList;
:}

| non_empty_function_call_parameter_list:paramsList T_COMMA T_REFERENCE:start w_variable:var
{:
	Expression var_ref = new ReferenceExpression(startleft, varright, var);
	paramsList.addNode(var_ref);
	RESULT = paramsList;
:}
;

global_var_list ::=
global_var_list:list T_COMMA global_var:var
{:
	list.add(var);
	RESULT = list;
:}

| global_var:var 
{:
	List list = new LinkedList();
	list.add(var);
	RESULT = list;
:}
;

global_var ::=
T_VARIABLE:var
{:
	VariableReference variable = new VariableReference(varleft, varright, var);
	RESULT = variable;
:}

| T_DOLLAR:start r_variable:var
{:
	ReflectionVariableReference ref = new ReflectionVariableReference(startleft, varright, var);
	RESULT = ref;
:}

| T_DOLLAR:start T_CURLY_OPEN expr:varName T_CURLY_CLOSE:end
{:
	ReflectionVariableReference var = new ReflectionVariableReference(startleft, endright, varName);
	RESULT = var;
:}
;

static_var_list ::=
static_var_list:list T_COMMA T_VARIABLE:var
{:
	VariableReference v = new VariableReference(varleft, varright, var); 
	list.add(v);
	RESULT = list;
:}

| static_var_list:list T_COMMA T_VARIABLE:var T_EQUAL static_scalar:expr
{:
	VariableReference v = new VariableReference(varleft, varright, var); 
	Assignment assignment = new Assignment(varleft, exprright, v, Assignment.OP_EQUAL, expr); 
	list.add(assignment);
	RESULT = list;
:}

| T_VARIABLE:var
{:
	VariableReference v = new VariableReference(varleft, varright, var); 
	List list = new LinkedList();
	list.add(v);
	RESULT = list;
:}

| T_VARIABLE:var T_EQUAL static_scalar:expr
{:
	VariableReference v = new VariableReference(varleft, varright, var); 
	Assignment assignment = new Assignment(varleft, exprright, v, Assignment.OP_EQUAL, expr); 
	List list = new LinkedList();
	list.add(assignment);
	RESULT = list;
:}	
;

class_statement_list ::=
class_statement_list:list class_statement:classStatement
{:
	if(!(parser.declarations.peek() instanceof TypeDeclaration)) {
		parser.declarations.pop();
	}
:}

| /* empty */
;

class_statement ::=
variable_modifiers:modifier class_variable_declaration:decList T_SEMICOLON
{:
	Iterator i = decList.iterator();
	while (i.hasNext()) {
		ASTNode[] decl = (ASTNode[]) i.next();
		VariableReference variable = (VariableReference)decl[0];
		Expression initializer = (Expression)decl[1];
		int start = variable.sourceStart();
		int end = (initializer == null ? variable.sourceEnd() : initializer.sourceEnd());
		parser.addDeclarationStatement(new PHPFieldDeclaration(variable, initializer, start, end, modifier.modifier, modifierleft, modifier.doc));
	}
:}

| constant_declaration:decList T_SEMICOLON
{:
	Iterator i = decList.iterator();
	while (i.hasNext()) {
		ASTNode[] decl = (ASTNode[]) i.next();
		ConstantReference constant = (ConstantReference)decl[0];
		Expression initializer = (Expression)decl[1];
		
		PHPDocBlock docBlock = null;
		if (decl.length == 3) {
			docBlock = (PHPDocBlock)decl[2];
		}
		int start = constant.sourceStart();
		int end = (initializer == null ? constant.sourceEnd() : initializer.sourceEnd());
		parser.addDeclarationStatement(new ConstantDeclaration(constant, initializer, decListleft, end, docBlock));
	}
:}

T_OPEN_PARENTHESE parameter_list:paramList T_CLOSE_PARENTHESE:closeParenthese
{:
	PHPMethodDeclaration functionDeclaration = (PHPMethodDeclaration)parser.declarations.peek();
	functionDeclaration.acceptArguments(paramList);
	functionDeclaration.setEnd(closeParentheseright);
:}
method_body:body
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration)parser.declarations.pop();
	if(body instanceof ASTError) {
		parser.reportError(new ASTError(methodDeclaration.sourceEnd() - 1, methodDeclaration.sourceEnd()), "syntax error, unfinished method declaration");
	}
	TypeDeclaration type = (TypeDeclaration)parser.declarations.peek();
	methodDeclaration.setDeclaringTypeName(type.getName());
:}
;

method_body ::=
T_SEMICOLON:end /* abstract method */
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration)parser.declarations.peek();
	methodDeclaration.getBody().setStart(endleft);
	methodDeclaration.getBody().setEnd(endright);
	methodDeclaration.setEnd(endright);
	RESULT = null;
:}
| T_CURLY_OPEN:start inner_statement_list:statementList T_CURLY_CLOSE:end
{:
	PHPMethodDeclaration methodDeclaration = (PHPMethodDeclaration)parser.declarations.peek();
	methodDeclaration.getBody().setStart(startleft);
	methodDeclaration.getBody().setEnd(endright);
	methodDeclaration.getBody().getStatements().clear();
	methodDeclaration.getBody().acceptStatements(statementList);
	methodDeclaration.setEnd(endright);
	RESULT = null;
:}
| /* error recovery */
{:
	parser.reportError();
	RESULT = new ASTError(0,0);
:}
;

variable_modifiers ::=
non_empty_member_modifiers:list
{:
	int result = 0;
	PHPDocBlock docBlock = null;
	for (Iterator it = list.iterator(); it.hasNext() ; ) {
		CompilerAstParser.ModifierDocPair modifier = (CompilerAstParser.ModifierDocPair)it.next();
		if (modifier.doc != null) {
			docBlock = modifier.doc;
		}
		result |= modifier.modifier;
	}
	RESULT = parser.new ModifierDocPair(result, docBlock);
:}
;

method_modifiers ::=
/* empty */
{:
	RESULT = null;
:}

| non_empty_member_modifiers:list
{:
	int result = 0;
	PHPDocBlock docBlock = null;
	for (Iterator it = list.iterator(); it.hasNext() ; ) {
		CompilerAstParser.ModifierDocPair modifier = (CompilerAstParser.ModifierDocPair)it.next();
		if (modifier.doc != null) {
			docBlock = modifier.doc;
		}
		result |= modifier.modifier;
	}
	RESULT = parser.new ModifierDocPair(result, docBlock);
:}
;

non_empty_member_modifiers ::=
member_modifier:modifier
{:
	List list = new LinkedList();
	list.add(modifier);
	RESULT = list;
:}

| non_empty_member_modifiers:list member_modifier:modifier
{:
	list.add(modifier);
	RESULT = list;
:}
;

member_modifier ::=
T_PUBLIC:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPublic, value);
:}

| T_PROTECTED:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccProtected, value);
:}

| T_PRIVATE:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccPrivate, value);
:}

| T_STATIC:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccStatic, value);
:}

| T_ABSTRACT:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccAbstract, value);
:}

| T_FINAL:value
{:
	RESULT = parser.new ModifierDocPair(Modifiers.AccFinal, value);
:}
;

class_variable_declaration ::=
class_variable_declaration:list T_COMMA T_VARIABLE:var
{:
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, null});
	RESULT = list;
:}

| class_variable_declaration:list T_COMMA T_VARIABLE:var T_EQUAL static_scalar:expr
{:
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, expr});
	RESULT = list;
:}

| T_VARIABLE:var
{:
	List list = new LinkedList();
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, null});
	RESULT = list;
:}

| T_VARIABLE:var T_EQUAL static_scalar:expr
{:
	List list = new LinkedList();
	VariableReference varId = new VariableReference(varleft, varright, var);
	list.add(new ASTNode[] {varId, expr});
	RESULT = list;
:}
;

expr_without_variable ::=
variable:var T_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var, Assignment.OP_EQUAL, expr); 
:}

| variable:var T_EQUAL T_REFERENCE:reftoken variable:refvar
{: 
	RESULT = new Assignment(varleft, refvarright, var, Assignment.OP_REF_EQUAL, refvar); 
:}

| variable:var T_EQUAL T_REFERENCE:reftoken T_NEW:start class_name_reference:className ctor_arguments:ctor
{:
	if (ctor.sourceStart() == 0) {
		ctor.setStart(classNameright);
		ctor.setEnd(classNameright);
	}
	ClassInstanceCreation classInstanceCreation = new ClassInstanceCreation(startleft, ctorright, className, ctor);
	Assignment assignment = new Assignment(varleft, ctorright, var, Assignment.OP_REF_EQUAL, classInstanceCreation);
	RESULT = assignment;
:} 

| T_NEW:start class_name_reference:className ctor_arguments:ctor
{:
	if (ctor.sourceStart() == 0) {
		ctor.setStart(classNameright);
		ctor.setEnd(classNameright);
	}
	ClassInstanceCreation classInstanceCreation = new ClassInstanceCreation(startleft, ctorright, className, ctor);
	RESULT = classInstanceCreation;
:}

| variable:var T_PLUS_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_PLUS_EQUAL, expr); 
:}

| variable:var T_MINUS_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_MINUS_EQUAL, expr); 
:}

| variable:var T_MUL_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_MUL_EQUAL, expr); 
:}

| variable:var T_DIV_EQUAL expr:expr
{: 	
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_DIV_EQUAL, expr); 
:}

| variable:var T_CONCAT_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_CONCAT_EQUAL, expr); 
:}

| variable:var T_MOD_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_MOD_EQUAL, expr); 
:}

| variable:var T_AND_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_AND_EQUAL, expr); 
:}

| variable:var T_OR_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_OR_EQUAL, expr); 
:}

| variable:var T_XOR_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_XOR_EQUAL, expr); 
:}

| variable:var T_SL_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_SL_EQUAL, expr); 
:}

| variable:var T_SR_EQUAL expr:expr
{: 
	RESULT = new Assignment(varleft, exprright, var , Assignment.OP_SR_EQUAL, expr); 
:}

| rw_variable:var T_INC:token
{: 
	RESULT = new PostfixExpression(varleft, tokenright, var , PostfixExpression.OP_INC); 
:} 

| T_INC:token rw_variable:var
{: 
	RESULT = new PrefixExpression(tokenleft, varright, var , PrefixExpression.OP_INC); 
:}
 
| rw_variable:var T_DEC:token
{: 
	RESULT = new PostfixExpression(varleft, tokenright, var , PostfixExpression.OP_DEC); 
:}
 
| T_DEC:token rw_variable:var
{: 
	RESULT = new PrefixExpression(tokenleft, varright, var , PrefixExpression.OP_DEC); 
:} 

| expr:expr1 T_BOOLEAN_OR expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_BOOL_OR, expr2); 
:}

| expr:expr1 T_BOOLEAN_AND expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_BOOL_AND, expr2); 
:}

| expr:expr1 T_LOGICAL_OR expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_STRING_OR, expr2); 
:}

| expr:expr1 T_LOGICAL_AND expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_STRING_AND, expr2); 
:}

| expr:expr1 T_LOGICAL_XOR expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_STRING_XOR, expr2);
:}

| expr:expr1 T_OR expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_OR, expr2); 
:}

| expr:expr1 T_REFERENCE expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_AND, expr2); 
:}

| expr:expr1 T_KOVA expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_XOR, expr2); 
:}

| expr:expr1 T_NEKUDA expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_CONCAT, expr2); 
:}

| expr:expr1 T_PLUS expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_PLUS, expr2); 
:}

| expr:expr1 T_MINUS expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_MINUS, expr2); 
:}

| expr:expr1 T_TIMES expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_MUL, expr2); 
:}

| expr:expr1 T_DIV expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_DIV, expr2); 
:}

| expr:expr1 T_PRECENT expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_MOD, expr2); 
:}

| expr:expr1 T_SL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_SL, expr2); 
:}

| expr:expr1 T_SR expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_SR, expr2); 
:}

| T_PLUS:token expr:expr
{: 
	RESULT = new UnaryOperation(tokenleft, exprright, expr , UnaryOperation.OP_PLUS); 
:}

| T_MINUS:token expr:expr
{: 
	RESULT = new UnaryOperation(tokenleft, exprright, expr , UnaryOperation.OP_MINUS); 
:}

| T_NOT:token expr:expr
{: 
	RESULT = new UnaryOperation(tokenleft, exprright, expr , UnaryOperation.OP_NOT); 
:}

| T_TILDA:token expr:expr
{: 
	RESULT = new UnaryOperation(tokenleft, exprright, expr , UnaryOperation.OP_TILDA); 
:}

| expr:expr1 T_IS_IDENTICAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_IDENTICAL, expr2); 
:}

| expr:expr1 T_IS_NOT_IDENTICAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_NOT_IDENTICAL, expr2); 
:}

| expr:expr1 T_IS_EQUAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_EQUAL, expr2); 
:}

| expr:expr1 T_IS_NOT_EQUAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_NOT_EQUAL, expr2); 
:}

| expr:expr1 T_RGREATER expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_RGREATER, expr2); 
:}

| expr:expr1 T_IS_SMALLER_OR_EQUAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_SMALLER_OR_EQUAL, expr2); 
:}

| expr:expr1 T_LGREATER expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_LGREATER, expr2); 
:}

| expr:expr1 T_IS_GREATER_OR_EQUAL expr:expr2
{: 
	RESULT = new InfixExpression(expr1left, expr2right, expr1 , InfixExpression.OP_IS_GREATER_OR_EQUAL, expr2); 
:}

| T_OPEN_PARENTHESE:start expr:expr T_CLOSE_PARENTHESE:end
{:
	RESULT = expr; 
:}

| expr:condition T_QUESTION_MARK expr:ifTrue T_NEKUDOTAIM expr:ifFalse
{: 
	RESULT = new ConditionalExpression(conditionleft, ifFalseright, condition , ifTrue, ifFalse); 
:}

| expr:condition T_QUESTION_MARK T_NEKUDOTAIM expr:ifFalse
{: 
	RESULT = new ConditionalExpression(conditionleft, ifFalseright, condition , null, ifFalse); 
:}

| internal_functions_in_yacc:expr
{:
	RESULT = expr;
:}

| T_INT_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_INT); 
:}

| T_DOUBLE_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_REAL); 
:}

| T_STRING_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_STRING); 
:}

| T_ARRAY_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_ARRAY); 
:}

| T_OBJECT_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_OBJECT); 
:}

| T_BOOL_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_BOOL); 
:}

| T_UNSET_CAST:token expr:expr
{: 
	RESULT = new CastExpression(tokenleft, exprright, expr , CastExpression.TYPE_UNSET); 
:}

| T_AT:start expr:expr 
{:
	IgnoreError ignoreError = new IgnoreError(startleft, exprright, expr);
	RESULT = ignoreError;
:}

| scalar:scalar
{: 
	RESULT = scalar; 
:}

| T_ARRAY:start T_OPEN_PARENTHESE array_pair_list:list T_CLOSE_PARENTHESE:end
{:
	Expression expr = new ArrayCreation(startleft, endright, list);
	RESULT = expr;
:}

| T_BACKQUATE:start backticks_expr:list T_BACKQUATE:end
{:
	BackTickExpression backTickExpression = new BackTickExpression(startleft, endright, list);
	RESULT = backTickExpression;
:}

| T_PRINT:start expr:expr
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	if (expr != null) {
		list.addNode(expr);
		list.setStart(expr.sourceStart());
		list.setEnd(expr.sourceEnd());
	} else {
		list.setStart(startright);
		list.setEnd(startright);
	}
	SimpleReference name = new SimpleReference(startleft, startright, "print");
	PHPCallExpression result = new PHPCallExpression(startleft, exprright, null, name, list);
	RESULT = result;
:}
;

lexical_vars ::=
/* empty */
{:
	RESULT = null;
:}
;

lexical_var_list ::=
lexical_var_list:list T_COMMA T_VARIABLE:var
{:
	VariableReference v = new VariableReference(varleft, varright, var);
	list.add(v);
	RESULT = list;
:}

| lexical_var_list:list T_COMMA T_REFERENCE:ref T_VARIABLE:var
{:
	list.add(new ReferenceExpression (refleft, varright, new VariableReference(varleft, varright, var)));
	RESULT = list;
:}

| T_VARIABLE:var
{:
	List list = new LinkedList();
	list.add(new VariableReference(varleft, varright, var));
	RESULT = list;
:}

| T_REFERENCE:ref T_VARIABLE:var
{:
	List list = new LinkedList();
	list.add(new ReferenceExpression (refleft, varright, new VariableReference(varleft, varright, var)));
	RESULT = list;
:}
;

function_call ::=
namespace_name:functionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	RESULT = new PHPCallExpression(functionNameleft, endright, null, functionName, parameters); 
:}

| class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:functionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{: 
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	SimpleReference name = new SimpleReference(functionNameleft, functionNameright, functionName);
	StaticMethodInvocation staticMethodInvocation = new StaticMethodInvocation(classNameleft, endright, className, name, parameters); 
	RESULT = staticMethodInvocation;
:}

| class_name:className T_PAAMAYIM_NEKUDOTAYIM variable_without_objects:reflectionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft); 
	ReflectionStaticMethodInvocation functionInvocation = new ReflectionStaticMethodInvocation(classNameleft, endright, className, reflectionName, parameters); 
	RESULT = functionInvocation;
:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:functionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{: 
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	SimpleReference name = new SimpleReference(functionNameleft, functionNameright, functionName);
	StaticMethodInvocation staticMethodInvocation = new StaticMethodInvocation(classNameleft, endright, className, name, parameters); 
	RESULT = staticMethodInvocation; 
:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM variable_without_objects:reflectionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{: 
	parameters.setStart(startright);
	parameters.setEnd(endleft); 
	ReflectionStaticMethodInvocation functionInvocation = new ReflectionStaticMethodInvocation(classNameleft, endright, className, reflectionName, parameters); 
	RESULT = functionInvocation; 
:}

| variable_without_objects:reflectionName T_OPEN_PARENTHESE:start function_call_parameter_list:parameters T_CLOSE_PARENTHESE:end
{:
	parameters.setStart(startright);
	parameters.setEnd(endleft);
	RESULT = new ReflectionCallExpression(reflectionNameleft, endright, null, reflectionName, parameters); 
:}
;

class_name ::=
T_STATIC:s
{:
	RESULT = new FullyQualifiedReference(sleft, sright, "static", null);
:}

| namespace_name:name
{:
	RESULT = name;
:}
;

class_name_reference ::=
class_name:className
{:
	RESULT = className;
:}

| dynamic_class_name_reference:className
{:
	RESULT = className;
:}
;

dynamic_class_name_reference ::=
base_variable:var T_OBJECT_OPERATOR object_property:firstVarProperty dynamic_class_name_variable_properties:propertyList
{:
	// then get the aggregated list of properties (->...->...->...)
	LinkedList list = (LinkedList) propertyList;
	list.addFirst(firstVarProperty);
	
	// now create the dispatch(es) nodes 
	Expression dispatcher = var;

	Iterator listIt = list.iterator();
	while (listIt.hasNext()) {
		Expression property = (Expression)listIt.next();
		dispatcher = parser.createDispatch(dispatcher, property);
	}	
	
	RESULT = dispatcher;
:}

| base_variable:var 
{:
	 RESULT = var;
:}
;

dynamic_class_name_variable_properties ::=
dynamic_class_name_variable_properties:variables dynamic_class_name_variable_property:var
{:
	variables.add(var);
	RESULT = variables;	
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

dynamic_class_name_variable_property ::=
T_OBJECT_OPERATOR object_property:var
{:
	RESULT = var;
:}
;

exit_expr ::=
/* empty */
{:
	RESULT = null;
:}

| T_OPEN_PARENTHESE T_CLOSE_PARENTHESE
{:
	RESULT = null;
:}

| T_OPEN_PARENTHESE expr:expr T_CLOSE_PARENTHESE
{:
	RESULT = expr;	
:}
;

backticks_expr ::=
/* empty */
{:
	RESULT = new LinkedList();
:}

| T_ENCAPSED_AND_WHITESPACE:string
{:
	List list = new LinkedList();
	Scalar scalar = new Scalar(stringleft, stringright, string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	RESULT = list;
:}

| encaps_list:list
{:
	RESULT = list;
:}
;

ctor_arguments ::=
/* empty */
{:
	RESULT = new PHPCallArgumentsList();
:}

| T_OPEN_PARENTHESE:start function_call_parameter_list:paramsList T_CLOSE_PARENTHESE:end
{:
	paramsList.setStart(startright);
	paramsList.setEnd(endleft);
	RESULT = paramsList;
:}
;

common_scalar ::=
T_LNUMBER:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_INT);
	RESULT = s;
:}

| T_DNUMBER:scalar
{: 
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_REAL);
	RESULT = s;
:}

| T_CONSTANT_ENCAPSED_STRING:scalar
{: 
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}

| T_LINE:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__LINE__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_FILE:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__FILE__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_DIR:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__DIR__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_CLASS_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__CLASS__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_METHOD_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__METHOD__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_FUNC_C:scalar
{:
	Scalar s = new Scalar(scalarleft, scalarright, "__FUNCTION__", Scalar.TYPE_SYSTEM);
	RESULT = s;
:}

| T_NS_C:scalar
{:
	RESULT = new Scalar(scalarleft, scalarright, "__NAMESPACE__", Scalar.TYPE_SYSTEM);
:}

;

static_scalar ::=  /* compile-time evaluated scalars */
common_scalar:scalar
{:
	RESULT = scalar;
:}

| namespace_name:name
{:
	if (name.getNamespace() == null) {
		RESULT = new Scalar(nameleft, nameright, name.getName(), Scalar.TYPE_STRING);
	} else {
		RESULT = name;
	}
:}


| T_PLUS:start static_scalar:expr
{:
	UnaryOperation op = new UnaryOperation(startleft, exprright, expr, UnaryOperation.OP_PLUS);
	RESULT = op;	
:}

| T_MINUS:start static_scalar:expr
{:
	UnaryOperation op = new UnaryOperation(startleft, exprright, expr, UnaryOperation.OP_MINUS);
	RESULT = op;	
:}

| T_ARRAY:start T_OPEN_PARENTHESE static_array_pair_list:list T_CLOSE_PARENTHESE:end
{:
	ArrayCreation array = new ArrayCreation(startleft, endright, list);
	RESULT = array;	
:}

| static_class_constant:classConstant
{:
	RESULT = classConstant;
:}
;

static_class_constant ::=
class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:varName
{:
	ConstantReference vname = new ConstantReference(varNameleft, varNameright, varName);
	StaticConstantAccess constant = new StaticConstantAccess(classNameleft, varNameright, className, vname); 
	RESULT = constant;
:}
;

scalar ::=
T_STRING_VARNAME:scalar
{:
	// TODO: check if this is a scalar
	Scalar s = new Scalar(scalarleft, scalarright, scalar, Scalar.TYPE_STRING);
	RESULT = s;
:}
| class_constant:classConstant
{:
	RESULT = classConstant;
:}
| namespace_name:name
{:
	if (name.getNamespace() == null) {
		RESULT = new Scalar(nameleft, nameright, name.getName(), Scalar.TYPE_STRING);
	} else {
		RESULT = name;
	}
:}
| common_scalar:scalar
{:
	RESULT = scalar;
:}
| T_QUATE:start encaps_list:list T_QUATE:end
{:
	Quote quote = new Quote(startleft, endright, list, Quote.QT_QUOTE);
	RESULT = quote;
:}
;

static_array_pair_list ::=
/* empty */
{:
	List list = new LinkedList();
	RESULT = list;
:}

| non_empty_static_array_pair_list:list possible_comma
{:
	RESULT = list;
:}
;

/* do nothing */
possible_comma ::=
/* empty */
| T_COMMA
;

non_empty_static_array_pair_list ::=
non_empty_static_array_pair_list:list T_COMMA static_scalar:key T_DOUBLE_ARROW static_scalar:value
{:
	ArrayElement element = new ArrayElement(keyleft, valueright, key, value);
	list.add(element);
	RESULT = list;
:}

| non_empty_static_array_pair_list:list T_COMMA static_scalar:value
{:
	ArrayElement element = new ArrayElement(valueleft, valueright, value);
	list.add(element);
	RESULT = list;
:}

| static_scalar:key T_DOUBLE_ARROW static_scalar:value
{:
	List list = new LinkedList();
	ArrayElement element = new ArrayElement(keyleft, valueright, key, value);
	list.add(element);
	RESULT = list;
:}

| static_scalar:value
{:
	List list = new LinkedList();
	ArrayElement element = new ArrayElement(valueleft, valueright, value);
	list.add(element);
	RESULT = list;
:}
;

expr ::=
r_variable:var
{: RESULT = var; :}

| expr_without_variable:ewv
{: RESULT = ewv; :}
;

r_variable ::=
variable:var
{: RESULT = var; :}
;

w_variable ::=
variable:var
{: RESULT = var; :}
;

rw_variable ::=
variable:var
{: RESULT = var; :}
;

variable ::=
base_variable_with_function_calls:var T_OBJECT_OPERATOR object_property:memberProperty method_or_not:paramsList variable_properties:propertyList
{:
	// get the last property 
	Expression firstVarProperty = null;
	if (paramsList == null) {
		firstVarProperty = memberProperty;
	} else {
		if (memberProperty.getClass().equals(SimpleReference.class)) {
			firstVarProperty = new PHPCallExpression(memberPropertyleft, paramsListright, null, (SimpleReference)memberProperty, paramsList);
		} else {
			firstVarProperty = new ReflectionCallExpression(memberPropertyleft, paramsListright, null, memberProperty, paramsList);
		}
	}

	// then get the aggregated list of properties (->...->...->...)
	LinkedList list = (LinkedList) propertyList;
	list.addFirst(firstVarProperty);
	
	// now create the dispatch(es) nodes 
	Expression dispatcher = var;
	
	Iterator listIt = list.iterator();
	while (listIt.hasNext()) {
		Expression property = (Expression)listIt.next();
		dispatcher = parser.createDispatch(dispatcher, property);
	}

	RESULT = dispatcher;
:}

| base_variable_with_function_calls:var
{: 
	RESULT = var; 
:}
;

variable_properties ::=
variable_properties:variables variable_property:variableProperty
{:
	variables.add(variableProperty);
	RESULT = variables;	
:}

| /* empty */
{:
	RESULT = new LinkedList();
:}
;

variable_property ::=
T_OBJECT_OPERATOR object_property:memberProperty method_or_not:paramsList
{:
	Expression result = null;
	if (paramsList == null) {
		result = memberProperty;
	} else {
		if (memberProperty.getClass().equals(SimpleReference.class)) {
			result = new PHPCallExpression(memberPropertyleft, paramsListright, null, (SimpleReference)memberProperty, paramsList);
		} else {
			result = new ReflectionCallExpression(memberPropertyleft, paramsListright, null, memberProperty, paramsList);
		}
	}
	RESULT = result;
:}
;

method_or_not ::=
T_OPEN_PARENTHESE:start function_call_parameter_list:paramsList T_CLOSE_PARENTHESE:end
{:
	paramsList.setStart(startright);
	paramsList.setEnd(endleft);
	RESULT = paramsList;	
:}

| /* empty */
{:
	RESULT = null;
:}
;

variable_without_objects ::=
reference_variable:var
{: 
	RESULT = var; 
:}

| simple_indirect_reference:ref_count reference_variable:var
{:
	// the ref_count counts the number of reflection (DOLLAR sign) so now we should 
	// accomulate the dolars into reflection variables
	Expression finalVar = var;
	for (int i=0; i<ref_count.intValue(); i++) {
		finalVar = new ReflectionVariableReference(ref_countright - i - 1, varright, finalVar);				
	}
	RESULT = finalVar;
:}
;

static_member ::=
class_name:className T_PAAMAYIM_NEKUDOTAYIM variable_without_objects:var
{:
	StaticFieldAccess staticFieldAccess = new StaticFieldAccess(classNameleft, varright, className, var);
	RESULT = staticFieldAccess;
:}

| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM variable_without_objects:var
{:
	StaticFieldAccess staticFieldAccess = new StaticFieldAccess(classNameleft, varright, className, var);
	RESULT = staticFieldAccess;
:}
;

variable_class_name ::=
reference_variable:var
{:
	RESULT = var;
:}
;

base_variable_with_function_calls ::=
base_variable:var
{: RESULT = var; :}

| function_call:var
{: RESULT = var; :}
;

base_variable ::=
reference_variable:var
{: 
	RESULT = var; 
:}

| simple_indirect_reference:ref_count reference_variable:var
{:
	// the ref_count counts the number of reflection (DOLLAR sign) so now we should 
	// accomulate the dolars into reflection variables
	Expression finalVar = var;
	for (int i=0; i<ref_count.intValue(); i++) {
		finalVar = new ReflectionVariableReference(ref_countright - i - 1, varright, finalVar);				
	}
	RESULT = finalVar;
:}

| static_member:staticFieldAccess
{:
	RESULT = staticFieldAccess;
:}
;

reference_variable ::=
reference_variable:varName T_OPEN_RECT dim_offset:index T_CLOSE_RECT:end
{:
	Expression var;
	if(varName.getKind() == ExpressionConstants.E_IDENTIFIER) { // VariableReference - $a
		var = new ArrayVariableReference(varNameleft, endright, ((SimpleReference)varName).getName(), index, ArrayVariableReference.VARIABLE_ARRAY);
	} else {
		var = new ReflectionArrayVariableReference(varNameleft, endright, varName, index, ReflectionArrayVariableReference.VARIABLE_ARRAY);
	}
	RESULT = var;
:}

| reference_variable:varName T_CURLY_OPEN expr:index T_CURLY_CLOSE:end
{:
	Expression var;
	if(varName.getKind() == ExpressionConstants.E_IDENTIFIER) { // VariableReference - $a
		var = new ArrayVariableReference(varNameleft, endright, ((SimpleReference)varName).getName(), index, ArrayVariableReference.VARIABLE_HASHTABLE);
	} else {
		var = new ReflectionArrayVariableReference(varNameleft, endright, varName, index, ReflectionArrayVariableReference.VARIABLE_HASHTABLE);
	}
	RESULT = var;
:}

| compound_variable:comp_var
{: RESULT = comp_var; :}
;

compound_variable ::=
tracked_variable:var
{: RESULT = var; :}

| T_DOLLAR:start T_CURLY_OPEN expr:expr T_CURLY_CLOSE:end
{:
	ReflectionVariableReference var = new ReflectionVariableReference(startleft, endright, expr);
	RESULT = var;	 
:}	
;

dim_offset ::=
/* empty */
{: 
	RESULT = null;
:}

| expr:expr 
{: 
	RESULT = expr; 
:}
;

object_property ::=
object_dim_list:var
{: 
	RESULT = var; 
:}

| variable_without_objects:var
{:
	RESULT = var;
:}
;

object_dim_list ::=
object_dim_list:var T_OPEN_RECT dim_offset:index T_CLOSE_RECT:end
{:
	Expression varArray;
	if(var.getKind() == ExpressionConstants.E_IDENTIFIER) { // VariableReference - $a
		varArray = new ArrayVariableReference(varleft, endright, ((SimpleReference)var).getName(), index, ArrayVariableReference.VARIABLE_ARRAY);
	} else {
		varArray = new ReflectionArrayVariableReference(varleft, endright, var, index, ReflectionArrayVariableReference.VARIABLE_ARRAY);
	}
	RESULT = varArray;	
:}

| object_dim_list:var T_CURLY_OPEN expr:index T_CURLY_CLOSE:end
{:
	Expression varArray;
	if(var.getKind() == ExpressionConstants.E_IDENTIFIER) { // VariableReference - $a
		varArray = new ArrayVariableReference(varleft, endright, ((SimpleReference)var).getName(), index, ArrayVariableReference.VARIABLE_HASHTABLE);
	} else {
		varArray = new ReflectionArrayVariableReference(varleft, endright, var, index, ReflectionArrayVariableReference.VARIABLE_HASHTABLE);
	}
	RESULT = varArray;	
:}

| variable_name:var
{: RESULT = var; :}
;

variable_name ::=
string_st:varName
{:
	RESULT = new SimpleReference(varNameleft, varNameright, varName); 
:}

| T_CURLY_OPEN:start expr:expr T_CURLY_CLOSE:end
{:
	RESULT = new ReflectionVariableReference(startleft, endright, expr); 
:}
;

simple_indirect_reference ::=
T_DOLLAR 
{:
	RESULT = new Integer(1);
:}

| simple_indirect_reference:ref T_DOLLAR
{:
	RESULT = new Integer(1 + ref.intValue());
:}
;

assignment_list ::=
assignment_list:listElements T_COMMA assignment_list_element:element
{:
	if (element != null) {
		listElements.add(element);
	}
	RESULT = listElements;
:}

| assignment_list_element:var
{:
	List listElements = new LinkedList();
	if (var != null) {
		listElements.add(var);	
	}
	RESULT = listElements;
	;
:}
;

assignment_list_element ::=
variable:var
{:
	RESULT = var;
:}

| /* empty */
{:
	RESULT = null;
:}
;

array_pair_list ::=
/* empty */
{:
	List list = new LinkedList();
	RESULT = list;	
:}

| non_empty_array_pair_list:list possible_comma
{:
	RESULT = list;
:}
;

non_empty_array_pair_list ::=
non_empty_array_pair_list:list T_COMMA expr:key T_DOUBLE_ARROW expr:value
{:
	ArrayElement element = new ArrayElement(keyleft, valueright, key, value);
	list.add(element);
	RESULT = list;
:}

| non_empty_array_pair_list:list T_COMMA expr:expr
{:
	ArrayElement element = new ArrayElement(exprleft, exprright, expr);
	list.add(element);
	RESULT = list;
:}

| expr:key T_DOUBLE_ARROW expr:value
{:
	List list = new LinkedList();
	ArrayElement element = new ArrayElement(keyleft, valueright, key, value);
	list.add(element);
	RESULT = list;
:}

| expr:expr
{:
	List list = new LinkedList();
	ArrayElement element = new ArrayElement(exprleft, exprright, expr);
	list.add(element);
	RESULT = list;
:}

| non_empty_array_pair_list:list T_COMMA expr:key T_DOUBLE_ARROW T_REFERENCE:start w_variable:var
{:
	ReferenceExpression value = new ReferenceExpression(startleft, varright, var);
	ArrayElement element = new ArrayElement(keyleft, varright, key, value);	
	list.add(element);
	RESULT = list;
:}

| non_empty_array_pair_list:list T_COMMA T_REFERENCE:start w_variable:var
{:
	ReferenceExpression ref = new ReferenceExpression(startleft, varright, var);
	ArrayElement element = new ArrayElement(startleft, varright, ref);	
	list.add(element);
	RESULT = list;
:}

| expr:key T_DOUBLE_ARROW T_REFERENCE:start w_variable:var
{:
	List list = new LinkedList();
	ReferenceExpression value = new ReferenceExpression(startleft, varright, var);
	ArrayElement element = new ArrayElement(keyleft, varright, key, value);	
	list.add(element);
	RESULT = list;
:}

| T_REFERENCE:start w_variable:var
{:
	List list = new LinkedList();
	ReferenceExpression ref = new ReferenceExpression(startleft, varright, var);
	ArrayElement element = new ArrayElement(startleft, varright, ref);	
	list.add(element);
	RESULT = list;
:}
;

encaps_list ::=
encaps_list:list encaps_var:var
{:
	list.add(var);
	RESULT = list;
:}

| encaps_list:list T_ENCAPSED_AND_WHITESPACE:string
{:
	Scalar scalar = new Scalar(stringleft, stringright, string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	RESULT = list;
:}

| encaps_var:var
{:
	List list = new LinkedList();
	list.add(var);
	RESULT = list;
:}

| T_ENCAPSED_AND_WHITESPACE:string encaps_var:var
{:
	List list = new LinkedList();
	Scalar scalar = new Scalar(stringleft, stringright, string, string == null ? Scalar.TYPE_UNKNOWN : Scalar.TYPE_STRING);
	list.add(scalar);
	list.add(var);
	RESULT = list;
:}
;

encaps_var ::=
tracked_variable:var
{:
	RESULT = var;
:}

| tracked_variable:varName T_OPEN_RECT encaps_var_offset:index T_CLOSE_RECT:end
{:
	VariableReference var = new ArrayVariableReference(varNameleft, endright, varName.getName(), index, ArrayVariableReference.VARIABLE_ARRAY);
	RESULT = var;
:}

| tracked_variable:var T_OBJECT_OPERATOR string_st:string
{:
	VariableReference property = new VariableReference(stringleft, stringright, string);
	Expression dispatch = parser.createDispatch(var, property);
	RESULT = dispatch;
:}

| T_DOLLAR_OPEN_CURLY_BRACES:start expr:expr T_CURLY_CLOSE:end
{:
	ReflectionVariableReference var = new ReflectionVariableReference(startleft, endright, expr);
	RESULT = var;
:}	

| T_DOLLAR_OPEN_CURLY_BRACES:start T_STRING_VARNAME:varName T_OPEN_RECT expr:index T_CLOSE_RECT T_CURLY_CLOSE:end
{:
	VariableReference indexedVar = new ArrayVariableReference(startleft, endright, varName, index, ArrayVariableReference.VARIABLE_ARRAY);
	RESULT = indexedVar;
:}

| T_CURLY_OPEN_WITH_DOLAR:start variable:var T_CURLY_CLOSE:end
{:
	ReflectionVariableReference ref = new ReflectionVariableReference(startleft, endright, var);
	RESULT = ref;
:}
;

encaps_var_offset ::=
string_st:string
{:
	Scalar scalar = new Scalar(stringleft,stringright, string, Scalar.TYPE_STRING);
	RESULT = scalar;
:}

| T_NUM_STRING:num
{:
	Scalar scalar = new Scalar(numleft,numright, num, Scalar.TYPE_REAL);
	RESULT = scalar;	
:}

| tracked_variable:var
{:
	RESULT = var;
:}
;

internal_functions_in_yacc ::=
T_ISSET:start T_OPEN_PARENTHESE:openPar isset_variables:varList T_CLOSE_PARENTHESE:end
{:
	varList.setStart(openParright);
	varList.setEnd(endleft);
	SimpleReference name = new SimpleReference(startleft, startright, "isset");
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, varList);
	RESULT = result;
:}

| T_EMPTY:start T_OPEN_PARENTHESE:openPar variable:var T_CLOSE_PARENTHESE:end
{:
	SimpleReference name = new SimpleReference(startleft, startright, "empty");
	PHPCallArgumentsList varList = new PHPCallArgumentsList(openParright, endleft);
	varList.addNode(var);
	PHPCallExpression result = new PHPCallExpression(startleft, endright, null, name, varList);
	RESULT = result;
:}
;

isset_variables ::=
variable:var 
{:
	PHPCallArgumentsList list = new PHPCallArgumentsList();
	list.addNode(var);
	RESULT = list;	
:}

| isset_variables:varList T_COMMA variable:var
{:
	varList.addNode(var);
	RESULT = varList;
:}
;

class_constant ::=
class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:varName
{:
	ConstantReference name = new ConstantReference(varNameleft, varNameright, varName);
	StaticConstantAccess constant = new StaticConstantAccess(classNameleft, varNameright, className, name); 
	RESULT = constant;
:}
| variable_class_name:className T_PAAMAYIM_NEKUDOTAYIM T_STRING:varName
{:
	ConstantReference name = new ConstantReference(varNameleft, varNameright, varName);
	StaticConstantAccess constant = new StaticConstantAccess(classNameleft, varNameright, className, name); 
	RESULT = constant; 
:}
;


tracked_variable ::=
T_VARIABLE:varName
{:
	RESULT = new VariableReference(varNameleft, varNameright, varName, PHPVariableKind.LOCAL);
:}
;

string_st ::=
T_STRING:value
{: RESULT = value; :}

| T_DEFINE:value
{: RESULT = value; :}
;
